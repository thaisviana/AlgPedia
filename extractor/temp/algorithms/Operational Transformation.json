{
    "about": "Operational transformation (OT) is a technology for supporting a range of collaboration functionalities in advanced collaborative software systems. OT was originally invented for consistency maintenance and concurrency control in collaborative editing of plain text documents. Two decades of research has extended its capabilities and expanded its applications to include group undo, locking, conflict resolution, operation notification and compression, group-awareness, HTML/XML and tree-structured document editing, collaborative office productivity tools, application-sharing, and collaborative computer-aided media design tools (see OTFAQ). In 2009 OT was adopted as a core technique behind the collaboration features in Apache Wave and Google Docs.", 
    "name": "Operational Transformation", 
    "classification": "Distributed Algorithms", 
    "full_text": "Operational transformation (OT) is a technology for supporting a range of collaboration functionalities in advanced collaborative software systems. OT was originally invented for consistency maintenance and concurrency control in collaborative editing of plain text documents. Two decades of research has extended its capabilities and expanded its applications to include group undo, locking, conflict resolution, operation notification and compression, group-awareness, HTML/XML and tree-structured document editing, collaborative office productivity tools, application-sharing, and collaborative computer-aided media design tools (see OTFAQ). In 2009 OT was adopted as a core technique behind the collaboration features in Apache Wave and Google Docs.\n\n\nOperational Transformation was pioneered by C. Ellis and S. Gibbs[1] in the GROVE (GRoup Outline Viewing Edit) system in 1989. Several years later, some correctness issues were identified and several approaches[2] [3] [4] [5] were independently proposed to solve these issues, which was followed by another decade of continuous efforts of extending and improving OT by a community of dedicated researchers. In 1998, a Special Interest Group on Collaborative Editing (SIGCE) was set up to promote communication and collaboration among CE and OT researchers. Since then, SIGCE holds annual CE workshops in conjunction with major CSCW (Computer Supported Cooperative Work) conferences, such as ACM CSCW, GROUP and ECSCW.\nCollaborative systems using OT typically adopt a replicated architecture for the storage of shared documents to ensure good responsiveness in high latency environments, such as the Internet. The shared documents are replicated at the local storage of each collaborating site, so editing operations can be performed at local sites immediately and then propagated to remote sites. Remote editing operations arriving at a local site are typically transformed and then executed. The transformation ensures that application-dependent consistency criteria are achieved across all sites. The lock-free, nonblocking property of OT makes the local response time not sensitive to networking latencies. As a result, OT is particularly suitable for implementing collaboration features such as group editing in the Web/Internet context.\nThe basic idea of OT can be illustrated by using a simple text editing scenario as follows. Given a text document with a string \"abc\" replicated at two collaborating sites; and two concurrent operations:\ngenerated by two users at collaborating sites 1 and 2, respectively. Suppose the two operations are executed in the order of O1 and O2 (at site 1). After executing O1, the document becomes \"xabc\". To execute O2 after O1, O2 must be transformed against O1 to become: O2' = Delete[3, \"c\"], whose positional parameter is incremented by one due to the insertion of one character \"x\" by O1. Executing O2' on \"xabc\" deletes the correct character \"c\" and the document becomes \"xab\". However, if O2 is executed without transformation, it incorrectly deletes character \"b\" rather than \"c\". The basic idea of OT is to transform (or adjust) the parameters of an editing operation according to the effects of previously executed concurrent operations so that the transformed operation can achieve the correct effect and maintain document consistency.\nOne functionality of OT is to support consistency maintenance in collaborative editing systems. A number of consistency models have been proposed in the research community, some generally for collaborative editing systems, and some specifically for OT algorithms.\nIn Ellis and Gibbs 1989 paper \"Concurrency control in groupware systems\",[1] two consistency properties are required for collaborative editing systems:\nSince concurrent operations may be executed in different orders and editing operations are not commutative in general, copies of the document at different sites may diverge (inconsistent). The first OT algorithm was proposed in Ellis and Gibbs's paper[1] to achieve convergence in a group text editor; the state-vector (or vector clock in classic distributed computing) was used to preserve the precedence property.\nThe CCI model was proposed as a consistency management in collaborative editing systems.[3][6] Under the CCI model, three consistency properties are grouped together:\nThe CCI model extends the CC model with a new criterion: intention preservation. The essential difference between convergence and intention preservation is that the former can always be achieved by a serialization protocol, but the latter may not be achieved by any serialization protocol if operations were always executed in their original forms. Achieving the nonserialisable intention preservation property has been a major technical challenge. OT has been found particularly suitable for achieving convergence and intention preservation in collaborative editing systems.\nThe CCI model is independent of document types or data models, operation types, or supporting techniques (OT, multi-versioning, serialization, undo/redo). It was not intended for correctness verification for techniques (e.g. OT) that are designed for specific data and operation models and for specific applications. In,[3] the notion of intention preservation was defined and refined at three levels: First, it was defined as a generic consistency requirement for collaborative editing systems; Second, it was defined as operation context-based pre- and post- transformation conditions for generic OT functions; Third, it was defined as specific operation verification criteria to guide the design of OT functions for two primitive operations: string-wise insert and delete, in collaborative plain text editors.\nThe condition of intention preservation was not formally specified in the CCI model for purposes of formal proofs. The SDT[7] and LBT[8] approaches try to formalize an alternative conditions that can be proved. The consistency model proposed in these two approaches consist of the following formal conditions:\nThe above CSM model requires that a total order of all objects in the system be specified. Effectively, the specification is reduced to new objects introduced by insert operations. However, specification of the total order entails application-specific policies such as those to break insertion ties (i.e., new objects inserted by two current operations at the same position). Consequently, the total order becomes application specific. Moreover, in the algorithm, the total order must be maintained in the transformation functions and control procedure, which increases time/space complexities of the algorithm.\nAlternatively, the CA model is based on the admissibility theory.[9] The CA model includes two aspects:\nThese two conditions imply convergence. All cooperating sites converge in a state in which there is a same set of objects that are in the same order. Moreover, the ordering is effectively determined by the effects of the operations when they are generated. Since the two conditions also impose additional constraints on object ordering, they are actually stronger than convergence. The CA model and the design/prove approach are elaborated in the 2005 paper.[9] It no longer requires that a total order of objects be specified in the consistency model and maintained in the algorithm, which hence results in reduced time/space complexities in the algorithm.\nOT is a system of multiple components. One established strategy of designing OT systems[1][2][3][4][10][11] is to separate the high-level transformation control (or integration) algorithms from the low-level transformation functions.\nThe transformation control algorithm is concerned with determining:\nThe control algorithm invokes a corresponding set of transformation functions, which determine how to transform one operation against another according to the operation types, positions, and other parameters. The correctness responsibilities of these two layers are formally specified by a set of transformation properties and conditions. Different OT systems with different control algorithms, functions, and communication topologies require maintaining different sets of transformation properties. The separation of an OT system into these two layers allows for the design of generic control algorithms that are applicable to different kinds of application with different data and operation models.\nThe other alternative approach was proposed in.[9] In their approach, an OT algorithm is correct if it satisfies two formalized correctness criteria:\nAs long as these two criteria are satisfied, the data replicas converge (with additional constraints) after all operations are executed at all sites. There is no need to enforce a total order of execution for the sake of achieving convergence. Their approach is generally to first identify and prove sufficient conditions for a few transformation functions, and then design a control procedure to ensure those sufficient conditions. This way the control procedure and transformation functions work synergistically to achieve correctness, i.e., causality and admissibility preservation. In their approach, there is no need to satisfy transformation properties such as TP2 because it does not require that the (inclusive) transformation functions work in all possible cases.\nThere exist two underlying models in each OT system: the data model that defines the way data objects in a document are addressed by operations, and the operation model that defines the set of operations that can be directly transformed by OT functions. Different OT systems may have different data and operation models. For example, the data model of the first OT system[1] is a single linear address space; and its operation model consists of two primitive operations: character-wise insert and delete. The basic operation model has been extended to include a third primitive operation update to support collaborative Word document processing[12] and 3D model editing.[13] The basic OT data model has been extended into a hierarchy of multiple linear addressing domains,[14][15] which is capable of modeling a broad range of documents. A data adaption process is often required to map application-specific data models to an OT-compliant data model.[16][17]\nThere exist two approaches to supporting application level operations in an OT system:\nVarious OT functions have been designed for OT systems with different capabilities and used for different applications. OT functions used in different OT systems may be named differently, but they can be classified into two categories:\nFor example, suppose a type String with an operation ins(p, c, sid) where p is the position of insertion, c the character to insert and sid is the identifier of the site that has generated the operation. We can write the following transformation function:\nSome OT systems use both IT and ET functions, and some use only IT functions. The complexity of OT function design is determined by various factors:\nVarious transformation properties for ensuring OT system correctness have been identified. These properties can be maintained by either the transformation control algorithm[3][4][11][17][23][24] or by the transformation functions.[25] Different OT system designs have different division of responsibilities among these components. The specifications of these properties and preconditions of requiring them are given below.\nThe following two properties are related to achieving convergence.\nThe following three properties are related to achieving the desired group undo effect. They are:\nVarious OT control algorithms have been designed for OT systems with different capabilities and for different applications. The complexity of OT control algorithm design is determined by multiple factors. A key differentiating factor is whether an algorithm is capable of supporting concurrency control (do) and/or group undo.[2][6][10][24][26] In addition, different OT control algorithm designs make different tradeoffs in:\nMost existing OT control algorithms for concurrency control adopts the theory of causality/concurrency as the theoretical basis: causally related operations must be executed in their causal order; concurrent operations must be transformed before their execution. However, it was well known that concurrency condition alone cannot capture all OT transformation conditions.[2][3][4][6][27] In a recent work, the theory of operation context has been proposed to explicitly represent the notion of a document state, which can be used to formally express OT transformation conditions for supporting the design and verification of OT control algorithms.[24]\nThe following table gives an overview of some existing OT control/integration algorithms\nA continuous total order is a strict total order where it possible to detect a missing element i.e. 1,2,3,4,... is a continuous total order, 1,2,3,5,... is not a continuous total order.\nThe transformation-based algorithms proposed in [8][9] are based on the alternative consistency models \"CSM\" and \"CA\" as described above. Their approaches differ from those listed in the table. They use vector timestamps for causality preservation. The other correctness conditions are \"single-\"/\"multi-\" operation effects relation preservation or \"admissibility\" preservation. Those conditions are ensured by the control procedure and transformation functions synergistically. There is no need to discuss TP1/TP2 in their work. Hence they are not listed in the above table.\nThere exist some other optimistic consistency control algorithms that seek alternative ways to design transformation algorithms, but do not fit well with the above taxonomy and characterization. For example, Mark and Retrace[30]\nThe correctness problems of OT led to introduction of transformationless post-OT schemes, such as WOOT,[31] Logoot[32] and Causal Trees (CT).[33] \"Post-OT\" schemes decompose the document into atomic operations, but they workaround the need to transform operations by employing a combination of unique symbol identifiers, vector timestamps and/or tombstones.\nWhile the classic OT approach of defining operations through their offsets in the text seems to be simple and natural, real-world distributed systems raise serious issues. Namely, that operations propagate with finite speed, states of participants are often different, thus the resulting combinations of states and operations are extremely hard to foresee and understand. As Li and Li put it, \"Due to the need to consider complicated case coverage, formal proofs are very complicated and error-prone, even for OT algorithms that only treat two characterwise primitives (insert and delete)\".[34]\nSimilarly, Joseph Gentle who is a former Google Wave engineer and an author of the Share.JS library wrote, \"Unfortunately, implementing OT sucks. There's a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. [\u2026] Wave took 2 years to write and if we rewrote it today, it would take almost as long to write a second time.\"[35]\nFor OT to work, every single change to the data needs to be captured: \"Obtaining a snapshot of the state is usually trivial, but capturing edits is a different matter altogether. [\u2026] The richness of modern user interfaces can make this problematic, especially within a browser-based environment.\" An alternative to OT is differential synchronization.[36]\nAnother alternative to OT is using sequence types of conflict-free replicated data type.", 
    "dbpedia_url": "http://dbpedia.org/resource/Operational_transformation", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Operational_transformation\n"
}