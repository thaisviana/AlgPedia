{
    "about": "Tournament sort is a sorting algorithm. It improves upon the naive selection sort by using a priority queue to find the next element in the sort. In the naive selection sort, it takes O(n) operations to select the next element of n elements; in a tournament sort, it takes O(log\u00a0n) operations (after building the initial tournament in O(n)). Tournament sort is a variation of heapsort.", 
    "name": "Tournament Sort", 
    "classification": "Sorting Algorithms", 
    "full_text": "Tournament sort is a sorting algorithm. It improves upon the naive selection sort by using a priority queue to find the next element in the sort. In the naive selection sort, it takes O(n) operations to select the next element of n elements; in a tournament sort, it takes O(log\u00a0n) operations (after building the initial tournament in O(n)). Tournament sort is a variation of heapsort.\n\n\nTournament replacement selection sorts are used to gather the initial runs for external sorting algorithms. Conceptually, an external file is read and its elements are pushed into the priority queue until the queue is full. Then the minimum element is pulled from the queue and written as part of the first run. The next input element is read and pushed into the queue, and the min is selected again and added to the run. There's a small trick that if the new element being pushed into the queue is less than the last element added to the run, then the element's sort value is increased so it will be part of the next run. On average, a run will be 100% longer than the capacity of the priority queue.[1]\nTournament sorts may also be used in N-way merges.\nThe name comes from its similarity to a single-elimination tournament where there are many players (or teams) that play in two-sided matches. Each match compares the players, and the winning player is promoted to play at match at the next level up. The hierarchy continues until the final match determines the ultimate winner. The tournament determines the best player, but the player who was beaten in the final match may not be the second best\u2014he may be inferior to other players the winner bested.\nThe following is an implementation of tournament sort in Haskell, based on Scheme code by Stepanov and Kershenbaum.[2]", 
    "dbpedia_url": "http://dbpedia.org/resource/Tournament_sort", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Tournament_sort\n"
}