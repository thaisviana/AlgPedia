{
    "about": "In computer programming, a string is traditionally a sequence of characters, either as a literal constant or as some kind of variable. The latter may allow its elements to be mutated and the length changed, or it may be fixed (after creation). A string is generally understood as a data type and is often implemented as an array of bytes (or words) that stores a sequence of elements, typically characters, using some character encoding. A string may also denote more general arrays or other sequence (or list) data types and structures.", 
    "name": "String (Computer Science)", 
    "classification": "Algorithms On Strings", 
    "full_text": "In computer programming, a string is traditionally a sequence of characters, either as a literal constant or as some kind of variable. The latter may allow its elements to be mutated and the length changed, or it may be fixed (after creation). A string is generally understood as a data type and is often implemented as an array of bytes (or words) that stores a sequence of elements, typically characters, using some character encoding. A string may also denote more general arrays or other sequence (or list) data types and structures.\nDepending on programming language and precise data type used, a variable declared to be a string may either cause storage in memory to be statically allocated for a predetermined maximum length or employ dynamic allocation to allow it to hold variable number of elements.\nWhen a string appears literally in source code, it is known as a string literal or an anonymous string.[1]\nIn formal languages, which are used in mathematical logic and theoretical computer science, a string is a finite sequence of symbols that are chosen from a set called an alphabet.\n\n\nLet \u03a3 be a non-empty finite set of symbols (alternatively called characters), called the alphabet. No assumption is made about the nature of the symbols. A string (or word) over \u03a3 is any finite sequence of symbols from \u03a3.[2] For example, if \u03a3 = {0,\u00a01}, then 01011 is a string over \u03a3.\nThe length of a string s is the number of symbols in s (the length of the sequence) and can be any non-negative integer; it is often denoted as |s|. The empty string is the unique string over \u03a3 of length 0, and is denoted \u03b5 or \u03bb.[2][3]\nThe set of all strings over \u03a3 of length n is denoted \u03a3n. For example, if \u03a3 = {0, 1}, then \u03a32 = {00, 01, 10, 11}. Note that \u03a30 = {\u03b5} for any alphabet \u03a3.\nThe set of all strings over \u03a3 of any length is the Kleene closure of \u03a3 and is denoted \u03a3*. In terms of \u03a3n,\nFor example, if \u03a3 = {0, 1}, then \u03a3* = {\u03b5, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, ...}. Although the set \u03a3* itself is countably infinite, each element of \u03a3* is a string of finite length.\nA set of strings over \u03a3 (i.e. any subset of \u03a3*) is called a formal language over \u03a3. For example, if \u03a3 = {0, 1}, the set of strings with an even number of zeros, {\u03b5, 1, 00, 11, 001, 010, 100, 111, 0000, 0011, 0101, 0110, 1001, 1010, 1100, 1111, ...}, is a formal language over \u03a3.\nConcatenation is an important binary operation on \u03a3*. For any two strings s and t in \u03a3*, their concatenation is defined as the sequence of symbols in s followed by the sequence of characters in t, and is denoted st. For example, if \u03a3 = {a, b, ..., z}, s = bear, and t = hug, then st = bearhug and ts = hugbear.\nString concatenation is an associative, but non-commutative operation. The empty string \u03b5 serves as the identity element; for any string s, \u03b5s = s\u03b5 = s. Therefore, the set \u03a3* and the concatenation operation form a monoid, the free monoid generated by \u03a3. In addition, the length function defines a monoid homomorphism from \u03a3* to the non-negative integers (that is, a function \n\n\n\nL\n:\n\n\u03a3\n\n\u2217\n\n\n\u21a6\n\nN\n\n\u222a\n{\n0\n}\n\n\n{\\displaystyle L:\\Sigma ^{*}\\mapsto \\mathbb {N} \\cup \\{0\\}}\n\n, such that \n\n\n\nL\n(\ns\nt\n)\n=\nL\n(\ns\n)\n+\nL\n(\nt\n)\n\n\u2200\ns\n,\nt\n\u2208\n\n\u03a3\n\n\u2217\n\n\n\n\n{\\displaystyle L(st)=L(s)+L(t)\\quad \\forall s,t\\in \\Sigma ^{*}}\n\n).\nA string s is said to be a substring or factor of t if there exist (possibly empty) strings u and v such that t = usv. The relation \"is a substring of\" defines a partial order on \u03a3*, the least element of which is the empty string.\nA string s is said to be a prefix of t if there exists a string u such that t = su. If u is nonempty, s is said to be a proper prefix of t. Symmetrically, a string s is said to be a suffix of t if there exists a string u such that t = us. If u is nonempty, s is said to be a proper suffix of t. Suffixes and prefixes are substrings of t. Both the relations \"is a prefix of\" and \"is a suffix of\" are prefix orders.\nA string s = uv is said to be a rotation of t if t = vu. For example, if \u03a3 = {0, 1} the string 0011001 is a rotation of 0100110, where u = 00110 and v = 01.\nThe reverse of a string is a string with the same symbols but in reverse order. For example, if s = abc (where a, b, and c are symbols of the alphabet), then the reverse of s is cba. A string that is the reverse of itself (e.g., s = madam) is called a palindrome, which also includes the empty string and all strings of length 1.\nIt is often useful to define an ordering on a set of strings. If the alphabet \u03a3 has a total order (cf. alphabetical order) one can define a total order on \u03a3* called lexicographical order. For example, if \u03a3 = {0, 1} and 0 < 1, then the lexicographical order on \u03a3* includes the relationships \u03b5 < 0 < 00 < 000 < ... < 0001 < 001 < 01 < 010 < 011 < 0110 < 01111 < 1 < 10 < 100 < 101 < 111 < 1111 < 11111 ... The lexicographical order is total if the alphabetical order is, but isn't well-founded for any nontrivial alphabet, even if the alphabetical order is.\nSee Shortlex for an alternative string ordering that preserves well-foundedness.\nA number of additional operations on strings commonly occur in the formal theory. These are given in the article on string operations.\nStrings admit the following interpretation as nodes on a graph:\nThe natural topology on the set of fixed-length strings or variable-length strings is the discrete topology, but the natural topology on the set of infinite strings is the limit topology, viewing the set of infinite strings as the inverse limit of the sets of finite strings. This is the construction used for the p-adic numbers and some constructions of the Cantor set, and yields the same topology.\nIsomorphisms between string representations of topologies can be found by normalizing according to the lexicographically minimal string rotation.\nA string datatype is a datatype modeled on the idea of a formal string. Strings are such an important and useful datatype that they are implemented in nearly every programming language. In some languages they are available as primitive types and in others as composite types. The syntax of most high-level programming languages allows for a string, usually quoted in some way, to represent an instance of a string datatype; such a meta-string is called a literal or string literal.\nAlthough formal strings can have an arbitrary (but finite) length, the length of strings in real languages is often constrained to an artificial maximum. In general, there are two types of string datatypes: fixed-length strings, which have a fixed maximum length to be determined at compile time and which use the same amount of memory whether this maximum is needed or not, and variable-length strings, whose length is not arbitrarily fixed and which can use varying amounts of memory depending on the actual requirements at run time. Most strings in modern programming languages are variable-length strings. Of course, even variable-length strings are limited in length \u2013 by the number of bits available to a pointer, and by the size of available computer memory. The string length can be stored as a separate integer (which may put an artificial limit on the length) or implicitly through a termination character, usually a character value with all bits zero. See also \"Null-terminated\" below.\nString datatypes have historically allocated one byte per character, and, although the exact character set varied by region, character encodings were similar enough that programmers could often get away with ignoring this, since characters a program treated specially (such as period and space and comma) were in the same place in all the encodings a program would encounter. These character sets were typically based on ASCII or EBCDIC.\nLogographic languages such as Chinese, Japanese, and Korean (known collectively as CJK) need far more than 256 characters (the limit of a one 8-bit byte per-character encoding) for reasonable representation. The normal solutions involved keeping single-byte representations for ASCII and using two-byte representations for CJK ideographs. Use of these with existing code led to problems with matching and cutting of strings, the severity of which depended on how the character encoding was designed. Some encodings such as the EUC family guarantee that a byte value in the ASCII range will represent only that ASCII character, making the encoding safe for systems that use those characters as field separators. Other encodings such as ISO-2022 and Shift-JIS do not make such guarantees, making matching on byte codes unsafe. These encodings also were not \"self-synchronizing\", so that locating character boundaries required backing up to the start of a string, and pasting two strings together could result in corruption of the second string (these problems were much less with EUC as any ASCII character did synchronize the encoding).\nUnicode has simplified the picture somewhat. Most programming languages now have a datatype for Unicode strings. Unicode's preferred byte stream format UTF-8 is designed not to have the problems described above for older multibyte encodings. UTF-8, UTF-16 and UTF-32 require the programmer to know that the fixed-size code units are different than the \"characters\", the main difficulty currently is incorrectly designed APIs that attempt to hide this difference (UTF-32 does make code points fixed-sized, but these are not \"characters\" due to composing codes).\nSome languages like C++ implement strings as templates that can be used with any datatype, but this is the exception, not the rule.\nSome languages, such as C++ and Ruby, normally allow the contents of a string to be changed after it has been created; these are termed mutable strings. In other languages, such as Java and Python, the value is fixed and a new string must be created if any alteration is to be made; these are termed immutable strings.\nStrings are typically implemented as arrays of bytes, characters, or code units, in order to allow fast access to individual units or substrings\u2014including characters when they have a fixed length. A few languages such as Haskell implement them as linked lists instead.\nSome languages, such as Prolog and Erlang, avoid implementing a dedicated string datatype at all, instead adopting the convention of representing strings as lists of character codes.\nRepresentations of strings depend heavily on the choice of character repertoire and the method of character encoding. Older string implementations were designed to work with repertoire and encoding defined by ASCII, or more recent extensions like the ISO 8859 series. Modern implementations often use the extensive repertoire defined by Unicode along with a variety of complex encodings such as UTF-8 and UTF-16.\nThe term byte string usually indicates a general-purpose string of bytes, rather than strings of only (readable) characters, strings of bits, or such. Byte strings often imply that bytes can take any value and any data can be stored as-is, meaning that there should be no value interpreted as a termination value.\nMost string implementations are very similar to variable-length arrays with the entries storing the character codes of corresponding characters. The principal difference is that, with certain encodings, a single logical character may take up more than one entry in the array. This happens for example with UTF-8, where single codes (UCS code points) can take anywhere from one to four bytes, and single characters can take an arbitrary number of codes. In these cases, the logical length of the string (number of characters) differs from the physical length of the array (number of bytes in use). UTF-32 avoids the first part of the problem.\nThe length of a string can be stored implicitly by using a special terminating character; often this is the null character (NUL), which has all bits zero, a convention used and perpetuated by the popular C programming language.[4] Hence, this representation is commonly referred to as a C string. This representation of an n-character string takes n + 1 space (1 for the terminator), and is thus an implicit data structure.\nIn terminated strings, the terminating code is not an allowable character in any string. Strings with length field do not have this limitation and can also store arbitrary binary data.\nAn example of a null-terminated string stored in a 10-byte buffer, along with its ASCII (or more modern UTF-8) representation as 8-bit hexadecimal numbers is:\nThe length of the string in the above example, \"FRANK\", is 5 characters, but it occupies 6 bytes. Characters after the terminator do not form part of the representation; they may be either part of other data or just garbage. (Strings of this form are sometimes called ASCIZ strings, after the original assembly language directive used to declare them.)\nUsing a special byte for terminating strings has historically appeared in both hardware and software, though sometimes with a value that was also a printing character. $ was used by many assembler systems, : used by CDC systems (this character had a value of zero), and the ZX80 used \"[5] since this was the string delimiter in its BASIC language.\nSomewhat similar, \"data processing\" machines like the IBM 1401 used a special word mark bit to delimit strings at the left, where the operation would start at the right. This bit had to be clear in all other parts of the string. This meant that, while the IBM 1401 had a seven-bit word, almost no-one ever thought to use this as a feature, and override the assignment of the seventh bit to (for example) handle ASCII codes.\nThe length of a string can also be stored explicitly, for example by prefixing the string with the length as a byte value; a convention used in many Pascal dialects, as a consequence, some people call such a string a Pascal string or P-string. Storing the string length as byte limits the maximum string length to 255. To avoid such limitations, improved implementations of P-strings use 16-, 32-, or 64-bit words to store the string length. When the length field covers the address space, strings are limited only by the available memory.\nIf the length is bounded, then it can be encoded in constant space, typically a machine word, thus leading to an implicit data structure, taking n + k space, where k is the number of characters in a word (8 for 8-bit ASCII on a 64-bit machine, 1 for 32-bit UTF-32/UCS-4 on a 32-bit machine, etc.). If the length is not bounded, encoding a length n takes log(n) space (see fixed-length code), so length-prefixed strings are a succinct data structure, encoding a string of length n in log(n) + n space.\nIn the latter case, the length-prefix field itself doesn't have fixed length, therefore the actual string data needs to be moved when the string grows such that the length field needs to be increased.\nHere is a Pascal string stored in a 10-byte buffer, along with its ASCII / UTF-8 representation:\nMany languages, including object-oriented ones, implement strings as records with an internal structure like:\nHowever, since the implementation is usually hidden, the string must be accessed and modified through member functions. text is a pointer to a dynamically allocated memory area, which might be expanded as needed. See also string (C++).\nBoth character termination and length codes limit strings: For example, C character arrays that contain null (NUL) characters cannot be handled directly by C string library functions: Strings using a length code are limited to the maximum value of the length code.\nBoth of these limitations can be overcome by clever programming.\nIt is possible to create data structures and functions that manipulate them that do not have the problems associated with character termination and can in principle overcome length code bounds. It is also possible to optimize the string represented using techniques from run length encoding (replacing repeated characters by the character value and a length) and Hamming encoding[clarification needed].\nWhile these representations are common, others are possible. Using ropes makes certain string operations, such as insertions, deletions, and concatenations more efficient.\nThe core data structure in a text editor is the one that manages the string (sequence of characters) that represents the current state of the file being edited. While that state could be stored in a single long consecutive array of characters, a typical text editor instead uses an alternative representation as its sequence data structure\u2014a gap buffer, a linked list of lines, a piece table, or a rope\u2014which makes certain string operations, such as insertions, deletions, and undoing previous edits, more efficient.[6]\nThe differing memory layout and storage requirements of strings can affect the security of the program accessing the string data. String representations requiring a terminating character are commonly susceptible to buffer overflow problems if the terminating character is not present, caused by a coding error or an attacker deliberately altering the data. String representations adopting a separate length field are also susceptible if the length can be manipulated. In such cases, program code accessing the string data requires bounds checking to ensure that it does not inadvertently access or change data outside of the string memory limits.\nString data is frequently obtained from user-input to a program. As such, it is the responsibility of the program to validate the string to ensure that it represents the expected format. Performing limited or no validation of user-input can cause a program to be vulnerable to code injection attacks.\nSometimes, strings need to be embedded inside a text file that is both human-readable and intended for consumption by a machine. This is needed in, for example, source code of programming languages, or in configuration files. In this case, the NUL character doesn't work well as a terminator since it is normally invisible (non-printable) and is difficult to input via a keyboard. Storing the string length would also be inconvenient as manual computation and tracking of the length is tedious and error-prone.\nTwo common representations are:\nWhile character strings are very common uses of strings, a string in computer science may refer generically to any sequence of homogeneously typed data. A bit string or byte string, for example, may be used to represent non-textual binary data retrieved from a communications medium. This data may or may not be represented by a string-specific datatype, depending on the needs of the application, the desire of the programmer, and the capabilities of the programming language being used. If the programming language's string implementation is not 8-bit clean, data corruption may ensue.\nC programmers draw a sharp distinction between a \"string\", aka a \"string of characters\", which by definition is always null terminated, vs. a \"byte string\" or \"pseudo string\" which may be stored in the same array but is often not null terminated. Using C string handling functions on such a \"byte string\" often seems to work, but later leads to security problems.[7][8][9]\nThere are many algorithms for processing strings, each with various trade-offs. Some categories of algorithms include:\nAdvanced string algorithms often employ complex mechanisms and data structures, among them suffix trees and finite state machines.\nThe name stringology was coined in 1984 by computer scientist Zvi Galil for the issue of algorithms and data structures used for string processing.[10]\nCharacter strings are such a useful datatype that several languages have been designed in order to make string processing applications easy to write. Examples include the following languages:\nMany Unix utilities perform simple string manipulations and can be used to easily program some powerful string processing algorithms. Files and finite streams may be viewed as strings.\nSome APIs like Multimedia Control Interface, embedded SQL or printf use strings to hold commands that will be interpreted.\nRecent scripting programming languages, including Perl, Python, Ruby, and Tcl employ regular expressions to facilitate text operations. Perl is particularly noted for its regular expression use,[11] and many other languages and applications implement Perl compatible regular expressions.\nSome languages such as Perl and Ruby support string interpolation, which permits arbitrary expressions to be evaluated and included in string literals.\nString functions are used to manipulate a string or change or edit the contents of a string. They also are used to query information about a string. They are usually used within the context of a computer programming language.\nThe most basic example of a string function is the string length function \u2013 the function that returns the length of a string (not counting any terminator characters or any of the string's internal structural information) and does not modify the string. This function is often named length or len. For example, length(\"hello world\") would return 11.\nIn some programming languages, a string buffer is an alternative to a string. It has the ability to be altered through adding or appending, whereas a String is normally fixed or immutable.\nJava's standard way to handle text is to use its String class. Any given String in Java is an immutable object, which means its state cannot be changed. A String has an array of characters. Whenever a String must be manipulated, any changes require the creation of a new String (which, in turn, involves the creation of a new array of characters, and copying of the original array). This happens even if the original String's value or intermediate Strings used for the manipulation are not kept.\nJava provides two alternate classes for string manipulation, called StringBuffer and StringBuilder. Both of these, like String, each has an array to hold characters. They, however, are mutable (its state can be altered). Their array of characters is not necessarily completely filled (as opposed to a String, whose array is always the exact required length for its contents). Thus, a StringBuffer or StringBuilder has the capability to add, remove, or change its state without creating a new object (and without the creation of a new array, and array copying). The exception to this is when its array is no longer of suitable length to hold its content (a case which rarely happens because of the default Dynamic memory allocation provided by the JVM). In this case, it is required to create a new array, and copy the contents.\nFor these reasons, Java would handle an expression like\nlike this:\nGenerally, a StringBuffer is more efficient than a String in string handling. However, this is not necessarily the case, since a StringBuffer will be required to recreate its character array when it runs out of space. Theoretically, this is possible to happen the same number of times as a new String would be required, although this is unlikely (and the programmer can provide length hints to prevent this). Either way, the effect is not noticeable in modern desktop computers.\nAs well, the shortcomings of arrays are inherent in a StringBuffer. In order to insert or remove characters at arbitrary positions, whole sections of arrays must be moved.\nThe method by which a StringBuffer is attractive in an environment with low processing power takes this ability by using too much memory, which is likely also at a premium in this environment. This point, however, is trivial, considering the space required for creating many instances of Strings in order to process them. As well, the StringBuffer can be optimized to \"waste\" as little memory as possible.\nThe StringBuilder class, introduced in J2SE 5.0, differs from StringBuffer in that it is unsynchronized. When only a single thread at a time will access the object, using a StringBuilder processes more efficiently than using a StringBuffer.\nStringBuffer and StringBuilder are included in the java.lang package.\nMicrosoft's .NET Framework has a StringBuilder class in its Base Class Library.", 
    "dbpedia_url": "http://dbpedia.org/resource/String_(computer_science)", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/String_(computer_science)\n"
}